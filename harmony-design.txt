// Harmony

// TODO: Paint in the texture a closed door for the bomb to fall.
// What are the important details for the models? 

// Night mode, mini map, propellers, projectiles, move cannon with mouse, enemies, collision, reset, "random" movement, 


// The user can control the cannon direction with the mouse.
// There are two axis of rotation that are controlled by the mouse.
// When the airplane dies, there is a screen with dead or alive
==============================
Main
------------------------------
// All of the bullets that aren't dead are saved to continue moving through space.
bullets: a queue of bullets that when a bullet dies, it is removed from it.
collect memory garbage
------------------------------
display()
	IF player is dead THEN
		draw "You lost" on the middle of screen
	ELSE IF player won THEN
		draw "You win" on the middle of screen
	draw current score on top-right of the window 
	update camera position
	arena.draw()
	player.draw()
	FOR EACH flying enemy
		// remeber that enemy uses the same class as the player.
		enemy.draw()
	FOR EACH ground enemy
		tank.draw()
	FOR EACH projectile
		projectile.draw()
------------------------------
addResetListener(ResetListener): void 
------------------------------
reset()
	FOR EACH reset listener
		listener.reset()
	remove all projectiles // bombs and bullets
------------------------------
idle()	
	// detect collision of each projectile with an obstacle
	FOR EACH projectile
		move projectile
		IF projectile is dead THEN
			remove projectile from queue
	remove all projectiles that died

	// make random movements for each enemy
	FOR EACH enemy
		compute enemy next position

	IF had taken off && !takeoff.move(dt) THEN
		enable control
	ELSE IF movement enabled THEN
		compute player next position
		IF the player hit an enemy THEN
			kill player
			kill enemy
			make explosion animation for both airplanes
		ELSE IF hit the wall of the arena THEN
			teleport()
		ELSE 
			set position of airplane
		// fire bullets at constant frequency
		FOR EACH enemy
			make a key press at its frequency
	// teleport enemies when they hit the wall
	FOR EACH enemy
		IF hit wall of the arena THEN
			teleport (enemy)
==============================



==============================
Propeller
------------------------------
rotation: AirplaneMovement
------------------------------
draw()
------------------------------
run(time)
	update propeller rotation using the angular velocity
getAngularVelocity(): angle
	// the angular velocity of the propeller depends of the current velocity. That's why have a reference to the movement object
	RETURN angular velocity factor * get movement velocity
==============================













// *** Airstrip ***



// The airstrip has light points on each side of it and there are painting
// tracks at each side as well. The airstrip though is constructed with a
// line that comes from the SVG file and must be converted to an actual
// airstrip. The width of the player influences the width of the airstrip, 
// but the airstrip considers that the width is already fixed.
==============================
Airstrip
------------------------------
// The line is used to know the start and end of the airstrip, while the
// width is used to know the sideways of the airstrip. This is twice the
// airplane diameter.
Airstrip(line, width)
------------------------------
setStripes(count)
------------------------------
draw()
	draw light
		get current light position
		put a light at left and right of the sides
	draw ground
		load black texture
	draw stripes
		load white texture
------------------------------
through time()
	get time elaspsed since last call
	IF accumulated time + elapsed time > time interval of each stripe THEN
		next stripe
	accumulate elapsed time
next stripe()
	IF last stripe THEN
		set as first stripe
	ELSE
		set as stripe + 1
==============================


// *** Cannon ***


==============================
Cannon
------------------------------
static
	load cannon model
------------------------------
horizontal: angle
vertical: angle
------------------------------
offset: position to be defined from the model
------------------------------
factors for both horizontal and vertical
------------------------------
mouseMoved(dx, dy)
	move(dd * factors)
move(dx, dy)
	update horizontal and vertical
------------------------------
getExit()
	return offset + direction * cannon length
getDirection()
	// use the same algorithm as the others
	r = cos(vertical)
	x = r * cos(horizontal)
	y = r * sin(horizontal)
	z = sin(vertical)
	return <x, y, z>
------------------------------
draw()
	translate to position
	rotate y by vertical
	rotate z by horizontal
	draw cannon object
==============================



==============================
Player
------------------------------
cannon: Cannon
------------------------------
mouseMoved(dx, dy)
	IF controlling THEN
		cannon.mouseMoved(dx, dy)
mousePressed(button)
	switch button
		case left
			fire()
		case right
			bomb()
------------------------------
fire()
	get cannon position
	get cannon direction
	get airplane velocity
	create bullet
	attach to Game the bullet as projectile
bomb()
	get door position
	get airplane velocity xy
	create bomb
	attach to Game the bomb as projectile
==============================



// *** Tank ***




==============================
EnemyBase
------------------------------
static {
	load obj file
}
------------------------------
Tank()
------------------------------
draw(): void
	IF not dead THEN
		draw tank
==============================




// *** Map ***




==============================
MapItem: interface
------------------------------
drawMap(): void
==============================

// subclasses that implements MapItem: Airplane, Arena, Tank, Airstrip




// *** Firing with the gun, bomb ***




==============================
bullet: projectile
------------------------------
enemy: bool
------------------------------
onRun()
	IF is from an enemy THEN
		IF the bullet hit the player THEN
			kill the bullet
			kill the player
	ELSE
		IF bullet hit an enemy THEN
			kill the bullet
			kill the enemy
			score
==============================


==============================
Bomb: projectile
------------------------------
velocity at z axis
------------------------------
Bomb()
Bomb(): static
	load bomb model
------------------------------
onRun()
	IF bomb hit an enemy base THEN
		remove bomb
		kill base
	ELSE IF bomb hit ground
		remove bomb
	ELSE
		update velocity at z axis
------------------------------
draw(): void
	uses the bomb model
==============================


==============================
projectile
------------------------------
position
velocity
------------------------------
draw(): abstract void
------------------------------
update(dt)
	compute next position
	onRun(dt, previous position, next position)
	move(next position)
		position = next position
------------------------------
// used to know if the projectile should be removed from the list of projectiles
isDead(): bool
==============================



